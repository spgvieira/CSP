import java.text.SimpleDateFormat

/**
    To run the experiement on the server you need to make that we are using java14. 
    To do so we first need to run $export JAVA_HOME = /usr/lib/jvm/java-14-openjdk-amd64
    Then inside Assignment2 directory we can run ./gradlew
 */

plugins {
    id 'java'
}

ext {
    inputs = [1000, 2000, 3000, 4000, 5000, 6000, 7000, 8000, 9000, 10000]
    threads = [1, 2, 4, 8, 16, 32]
    repeat = 5
    perfEventsList = 'task-clock,context-switches,cpu-migrations,page-faults,major-faults,dTLB-load-misses,cache-misses'
    resultsDir = file("experimental_results")
    memDir = file("mem_reports")
    perfDir = file("perf_reports")
}

def registerMemoryTask(name, groupName, mainClassName, algo, isParallel = false){
    tasks.register(name, JavaExec) {
        group = groupName
        classpath = sourceSets.main.runtimeClasspath
        mainClass.set(mainClassName)

        doFirst {
            def dateStr = new SimpleDateFormat("dd_MM").format(new Date())
            def fileName = "${dateStr}_${groupName}.csv"
            def timeFile = file("${resultsDir}/${algo}/${fileName}")
            def memFile = file("${memDir}/${algo}/${fileName}")

            project.ext["${name}_timeFile"] = timeFile
            project.ext["${name}_memFile"] = memFile

            timeFile.text = isParallel ?
                "input,thread,${(1..repeat).collect { "time${it}" }.join(',')}\n" :
                "input,${(1..repeat).collect { "time${it}" }.join(',')}\n"
            // memReportFile.text = "Input,Thread,Timestamp,MemoryUsage(MB)\n"
        }
        doLast {
            def timeFile = project.ext["${name}_timeFile"]
            def memFile = project.ext["${name}_memFile"]
            def inputs = project.ext.inputs
            def threads = project.ext.threads
            def repeat = project.ext.repeat 

            def memoryScript = file("memory.sh").absolutePath

            inputs.each { inputSize ->
                def threadLoop = isParallel ? threads : [null]
                threadLoop.each { threadCount ->
                    println "Running with input size $inputSize" + (isParallel ? " and threads $threadCount" : "")
                    def times = []
                    for (int i = 0; i < repeat; i++) {
                        def argsList = isParallel ? [inputSize.toString(), threadCount.toString()] : [inputSize.toString()]

                        def processBuilder = new ProcessBuilder(
                            "java", "-cp", classpath.asPath, mainClassName, *argsList
                        )

                        def process = processBuilder.start()
                        def pid = process.pid()

                        def memScriptProcess = new ProcessBuilder(
                            "sh", memoryScript, pid.toString(), memFile.absolutePath, *argsList
                        ).inheritIO().start()

                        def reader = new BufferedReader(new InputStreamReader(process.inputStream))
                        def output = new StringBuilder()
                        String line
                        while ((line = reader.readLine()) != null) {
                            output.append(line).append("\n")
                        }

                        process.waitFor()
                        memScriptProcess.waitFor()

                        def timeTaken = output.toString().trim()
                        times.add(timeTaken)
                    }

                    def line = isParallel ? "$inputSize,$threadCount,${times.join(',')}" : "$inputSize,${times.join(',')}"
                    timeFile << "$line\n"
                }
            }
        }
    }
}

def registerPerfTask(name, groupName, mainClassName, algo, isParallel = false) {
    tasks.register(name, JavaExec) {
        group = groupName
        classpath = sourceSets.main.runtimeClasspath
        mainClass.set(mainClassName)

        doFirst {
            def dateStr = new SimpleDateFormat("dd_MM").format(new Date())
            def fileName = "${dateStr}_${groupName}"
            def timeFile = file("${resultsDir}/${algo}/${fileName}.csv")
            def perfReportFile = file("${perfDir}/${algo}/${fileName}.txt")
            project.ext["${name}_timeFile"] = timeFile
            project.ext["${name}_perfFile"] = perfReportFile

            timeFile.text = isParallel ?
                "input,thread,${(1..repeat).collect { "time${it}" }.join(',')}\n" :
                "input,${(1..repeat).collect { "time${it}" }.join(',')}\n"
        }

        doLast {
            def timeFile = project.ext["${name}_timeFile"]
            def perfReportFile = project.ext["${name}_perfFile"]
            def inputs = project.ext.inputs
            def threads = project.ext.threads
            def perfEvents = project.ext.perfEventsList
            def repeat = project.ext.repeat

            inputs.each { inputSize ->
                def threadLoop = isParallel ? threads : [null]
                threadLoop.each { threadCount ->
                    println "Running with input size $inputSize" + (isParallel ? " and threads $threadCount" : "")
                    def times = []
                    for (int i = 0; i < repeat; i++) {
                        def argsList = isParallel ? [inputSize.toString(), threadCount.toString()] : [inputSize.toString()]

                        def processBuilder = new ProcessBuilder(
                            "perf", "stat",
                            "-e", perfEvents,
                            "-o", perfReportFile.absolutePath, "--append",
                            "java", "-cp", classpath.asPath, mainClassName, *argsList
                        )
                        def process = processBuilder.start()

                        def reader = new BufferedReader(new InputStreamReader(process.inputStream))
                        def output = new StringBuilder()
                        String line
                        while ((line = reader.readLine()) != null) {
                            output.append(line).append("\n")
                        }
                        process.waitFor()
                        def timeTaken = output.toString().trim()
                        times.add(timeTaken)
                    }

                    def line = isParallel ? "$inputSize,$threadCount,${times.join(',')}" : "$inputSize,${times.join(',')}"
                    timeFile << "$line\n"
                }
            }
        }
    }
}

registerMemoryTask("memoryImperativeSequential", "imperative_sequential", "assignment2.SepctralNorm.ImperativeSequentialSpectralNorm", "spectral_norm",false)
registerMemoryTask("memoryImperativeParallel", "imperative_parallel", "assignment2.SepctralNorm.ImperativeParallelSpectralNorm", "spectral_norm",true)
registerMemoryTask("memoryFunctionalSequential", "functional_sequential", "assignment2.SepctralNorm.FunctionalSequentialSpectralNorm", "spectral_norm",false)
registerMemoryTask("memoryFunctionalParallel", "functional_parallel", "assignment2.SepctralNorm.FunctionalParallelSpectralNorm", "spectral_norm",true)

registerPerfTask("perfImperativeSequential", "imperative_sequential", "assignment2.SepctralNorm.ImperativeSequentialSpectralNorm", "spectral_norm",false)
registerPerfTask("perfImperativeParallel", "imperative_parallel", "assignment2.SepctralNorm.ImperativeParallelSpectralNorm", "spectral_norm",true)
registerPerfTask("perfFunctionalSequential", "functional_sequential", "assignment2.SepctralNorm.FunctionalSequentialSpectralNorm", "spectral_norm",false)
registerPerfTask("perfFunctionalParallel", "functional_parallel", "assignment2.SepctralNorm.FunctionalParallelSpectralNorm", "spectral_norm",true)

tasks.register("runAllMemoryTasks") {
    dependsOn("memoryImperativeSequential", "memoryImperativeParallel", "memoryFunctionalSequential", "memoryFunctionalParallel")
    group = "memory"
}

tasks.register("runAllPerfTasks") {
    dependsOn("perfImperativeSequential", "perfImperativeParallel", "perfFunctionalSequential", "perfFunctionalParallel")
    group = "performance"
}
