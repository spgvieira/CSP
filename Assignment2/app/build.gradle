import java.text.SimpleDateFormat

plugins {
    id 'java'
}

def resultsDir = file("experimental_results")
def perfDir = file("perf_reports")
def inputs = [1000, 2000, 3000, 4000, 5000, 6000, 7000, 8000, 9000, 10000]
def threads = [1,2,4,8,16,32,64,128]
def dateStr = new SimpleDateFormat("dd_MM").format(new Date())
def repeat = 5

def perfEvents = 'task-clock,context-switches,cpu-migrations,page-faults,major-faults,kmalloc,kfree,brk,mmap'

tasks.register("imperativeSequentialSpectralNorm", JavaExec) {
    group = "imperative_sequential"
    classpath = sourceSets.main.runtimeClasspath
    mainClass.set("assignment2.ImperativeSequentialSpectralNorm")

    def groupName = group
    def timeFileName = "${dateStr}_${groupName}_time.csv"
    def timeFile = file("${resultsDir}/${timeFileName}")
    def perfReportName = "${dateStr}_${groupName}_perf.data"
    def perfReportFile = file("${perfDir}/${perfReportName}")

    doFirst {
        timeFile.text = "input,${(1..repeat).collect { "time${it}" }.join(',')}\n"
    }

    doLast {
        inputs.each { inputSize ->
            println "Running with input size $inputSize"
            def times = []
            for (int i = 0; i < repeat; i++) {
                def output = new ByteArrayOutputStream()
                exec {
                    commandLine 'perf', 'stat',
                            '-e', perfEvents,
                            '-o', perfReportFile.absolutePath, '--append',
                            'java', '-cp', classpath.asPath, mainClass.get(), inputSize.toString()
                    standardOutput = output
                    errorOutput = output
                    ignoreExitValue = true
                }
                def timeTaken = output.toString().trim()
                times.add(timeTaken)
            }
            timeFile << "$inputSize,${times.join(',')}\n"
        }
    }
}

tasks.register("imperativeParallelSpectralNorm", JavaExec) {
    group = "imperative_parallel"
    classpath = sourceSets.main.runtimeClasspath
    mainClass.set("assignment2.ImperativeParallelSpectralNorm")

    def groupName = group
    def timeFileName = "${dateStr}_${groupName}_time.csv"
    def timeFile = file("${resultsDir}/${timeFileName}")
    def perfReportName = "${dateStr}_${groupName}_perf.data"
    def perfReportFile = file("${perfDir}/${perfReportName}")

    doFirst {
        timeFile.text = "input,thread,${(1..repeat).collect { "time${it}" }.join(',')}\n"
    }

    doLast {
        inputs.each { inputSize ->
            threads.each { threadCount ->
                println "Running with input size $inputSize and threads $threadCount"
                def times = []
                for (int i = 0; i < repeat; i++) {
                    def output = new ByteArrayOutputStream()
                    exec {
                        commandLine 'perf', 'stat',
                                '-e', perfEvents,
                                '-o', perfReportFile.absolutePath, '--append',
                                'java', '-cp', classpath.asPath, mainClass.get(), inputSize.toString(), threadCount.toString()
                        standardOutput = output
                        errorOutput = output
                        ignoreExitValue = true
                    }
                    def timeTaken = output.toString().trim()
                    times.add(timeTaken)
                }
                timeFile << "$inputSize,$threadCount,${times.join(',')}\n"
            }
        }
    }
}

tasks.register("functionalSequentialSpectralNorm", JavaExec) {
    group = "functional_sequential"
    classpath = sourceSets.main.runtimeClasspath
    mainClass.set("assignment2.FunctionalSequentialSpectralNorm")

    def groupName = group
    def timeFileName = "${dateStr}_${groupName}_time.csv"
    def timeFile = file("${resultsDir}/${timeFileName}")
    def perfReportName = "${dateStr}_${groupName}_perf.data"
    def perfReportFile = file("${perfDir}/${perfReportName}")

    doFirst {
        timeFile.text = "input,${(1..repeat).collect { "time${it}" }.join(',')}\n"
    }

    doLast {
        inputs.each { inputSize ->
            println "Running with input size $inputSize"
            def times = []
            for (int i = 0; i < repeat; i++) {
                def output = new ByteArrayOutputStream()
                exec {
                    commandLine 'perf', 'stat',
                            '-e', perfEvents,
                            '-o', perfReportFile.absolutePath, '--append',
                            'java', '-cp', classpath.asPath, mainClass.get(), inputSize.toString()
                    standardOutput = output
                    errorOutput = output
                    ignoreExitValue = true
                }
                def timeTaken = output.toString().trim()
                times.add(timeTaken)
            }
            timeFile << "$inputSize,${times.join(',')}\n"
        }
    }
}

tasks.register("functionalParallelSpectralNorm", JavaExec) {
    group = "functional_parallel"
    classpath = sourceSets.main.runtimeClasspath
    mainClass.set("assignment2.FunctionalParallelSpectralNorm")

    def groupName = group
    def timeFileName = "${dateStr}_${groupName}_time.csv"
    def timeFile = file("${resultsDir}/${timeFileName}")
    def perfReportName = "${dateStr}_${groupName}_perf.data"
    def perfReportFile = file("${perfDir}/${perfReportName}")

    doFirst {
        timeFile.text = "input,thread,${(1..repeat).collect { "time${it}" }.join(',')}\n"
    }

    doLast {
        inputs.each { inputSize ->
            threads.each { threadCount ->
                println "Running with input size $inputSize and threads $threadCount"
                def times = []
                for (int i = 0; i < repeat; i++) {
                    def output = new ByteArrayOutputStream()
                    exec {
                        commandLine 'perf', 'stat',
                                '-e', perfEvents,
                                '-o', perfReportFile.absolutePath, '--append',
                                'java', '-cp', classpath.asPath, mainClass.get(), inputSize.toString(), threadCount.toString()
                        standardOutput = output
                        errorOutput = output
                        ignoreExitValue = true
                    }
                    def timeTaken = output.toString().trim()
                    times.add(timeTaken)
                }
                timeFile << "$inputSize,$threadCount,${times.join(',')}\n"
            }
        }
    }
}