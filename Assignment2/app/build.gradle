import java.text.SimpleDateFormat

plugins {
    id 'java'
}

def resultsDir = file("experimental_results")
def perfDir = file("perf_reports")
def inputs = [1000, 2000, 3000]
def dateStr = new SimpleDateFormat("dd_MM").format(new Date())
def repeat = 5

tasks.register("imperativeSequentialSpectralNorm", JavaExec) {
    group = "imperative_sequential"
    classpath = sourceSets.main.runtimeClasspath
    mainClass.set("assignment2.ImperativeSequentialSpectralNorm")

    def groupName = group
    def timeFileName = "${dateStr}_${groupName}_time.csv"
    def timeFile = file("${resultsDir}/${timeFileName}")
    def perfReportName = "${dateStr}_${groupName}_perf.data"
    def perfReportFile = file("${perfDir}/${perfReportName}")

    doFirst {
        resultsDir.mkdirs()
        perfDir.mkdirs()
        timeFile.text = "input,time_taken\n"
    }

    doLast {
        inputs.each { inputSize ->
            println "Running with input size $inputSize"
            def output = new ByteArrayOutputStream()
            exec {
                commandLine 'perf', 'stat', '-o', perfReportFile.absolutePath, '--append', "--repeat=${repeat}" ,
                        'java', '-cp', classpath.asPath, mainClass.get(), inputSize.toString()
                standardOutput = output
                errorOutput = output
                ignoreExitValue = true
            }
            def timeTaken = output.toString().trim()
            timeFile << "$inputSize,$timeTaken\n"
        }
        println "Perf report for ${groupName} generated at: ${perfReportFile.absolutePath}"
    }
}

tasks.register("imperativeParallelSpectralNorm", JavaExec) {
    group = "imperative_parallel"
    classpath = sourceSets.main.runtimeClasspath
    mainClass.set("assignment2.ImperativeParallelSpectralNorm")

    def groupName = group
    def timeFileName = "${dateStr}_${groupName}_time.csv"
    def timeFile = file("${resultsDir}/${timeFileName}")
    def perfReportName = "${dateStr}_${groupName}_perf.data"
    def perfReportFile = file("${perfDir}/${perfReportName}")

    doFirst {
        timeFile.text = "input,time_taken\n"
    }

    doLast {
        inputs.each { inputSize ->
            println "Running with input size $inputSize"
            def output = new ByteArrayOutputStream()
            exec {
                commandLine 'perf', 'stat', '-o', perfReportFile.absolutePath, '--append', "--repeat=${repeat}" ,
                        'java', '-cp', classpath.asPath, mainClass.get(), inputSize.toString()
                standardOutput = output
                errorOutput = output
                ignoreExitValue = true
            }
            def timeTaken = output.toString().trim()
            timeFile << "$inputSize,$timeTaken\n"
        }
        println "Perf report for ${groupName} generated at: ${perfReportFile.absolutePath}"
    }
}

tasks.register("functionalSequentialSpectralNorm", JavaExec) {
    group = "functional_sequential"
    classpath = sourceSets.main.runtimeClasspath
    mainClass.set("assignment2.FunctionalSequentialSpectralNorm")

    def groupName = group
    def timeFileName = "${dateStr}_${groupName}_time.csv"
    def timeFile = file("${resultsDir}/${timeFileName}")
    def perfReportName = "${dateStr}_${groupName}_perf.data"
    def perfReportFile = file("${perfDir}/${perfReportName}")

    doFirst {
        timeFile.text = "input,time_taken\n"
    }

    doLast {
        inputs.each { inputSize ->
            println "Running with input size $inputSize"
            def output = new ByteArrayOutputStream()
            exec {
                commandLine 'perf', 'stat', '-o', perfReportFile.absolutePath, '--append', "--repeat=${repeat}" ,
                        'java', '-cp', classpath.asPath, mainClass.get(), inputSize.toString()
                standardOutput = output
                errorOutput = output
                ignoreExitValue = true
            }
            def timeTaken = output.toString().trim()
            timeFile << "$inputSize,$timeTaken\n"
        }
        println "Perf report for ${groupName} generated at: ${perfReportFile.absolutePath}"
    }
}

tasks.register("functionalParallelSpectralNorm", JavaExec) {
    group = "functional_parallel"
    classpath = sourceSets.main.runtimeClasspath
    mainClass.set("assignment2.FunctionalParallelSpectralNorm")

    def groupName = group
    def timeFileName = "${dateStr}_${groupName}_time.csv"
    def timeFile = file("${resultsDir}/${timeFileName}")
    def perfReportName = "${dateStr}_${groupName}_perf.data"
    def perfReportFile = file("${perfDir}/${perfReportName}")

    doFirst {
        timeFile.text = "input,time_taken\n"
    }

    doLast {
        inputs.each { inputSize ->
            println "Running with input size $inputSize"
            def output = new ByteArrayOutputStream()
            exec {
                commandLine 'perf', 'stat', '-o', perfReportFile.absolutePath, '--append', "--repeat=${repeat}" ,
                        'java', '-cp', classpath.asPath, mainClass.get(), inputSize.toString()
                standardOutput = output
                errorOutput = output
                ignoreExitValue = true
            }
            def timeTaken = output.toString().trim()
            timeFile << "$inputSize,$timeTaken\n"
        }
        println "Perf report for ${groupName} generated at: ${perfReportFile.absolutePath}"
    }
}